<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Dockerfile multi-stage pour optimiser la taille de l'image&#10;&#10;# Stage 1: Build&#10;FROM openjdk:17-jdk-slim AS build&#10;&#10;# Installer Maven&#10;RUN apt-get update &amp;&amp; apt-get install -y maven &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Définir le répertoire de travail&#10;WORKDIR /app&#10;&#10;# Copier les fichiers de configuration Maven&#10;COPY pom.xml .&#10;COPY mvnw .&#10;COPY mvnw.cmd .&#10;COPY .mvn .mvn&#10;&#10;# Télécharger les dépendances (layer séparé pour le cache Docker)&#10;RUN mvn dependency:go-offline -B&#10;&#10;# Copier le code source&#10;COPY src ./src&#10;&#10;# Construire l'application&#10;RUN mvn clean package -DskipTests&#10;&#10;# Stage 2: Runtime&#10;FROM openjdk:17-jre-slim AS runtime&#10;&#10;# Créer un utilisateur non-root pour la sécurité&#10;RUN addgroup --system --gid 1001 spring &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 spring&#10;&#10;# Définir le répertoire de travail&#10;WORKDIR /app&#10;&#10;# Copier le JAR depuis le stage de build&#10;COPY --from=build /app/target/*.jar app.jar&#10;&#10;# Changer le propriétaire du fichier&#10;RUN chown spring:spring app.jar&#10;&#10;# Passer à l'utilisateur non-root&#10;USER spring:spring&#10;&#10;# Exposer le port par défaut de Spring Boot&#10;EXPOSE 8080&#10;&#10;# Variables d'environnement pour optimiser la JVM&#10;ENV JAVA_OPTS=&quot;-Xmx512m -Xms256m -XX:+UseG1GC -XX:+UseContainerSupport&quot;&#10;&#10;# Point d'entrée de l'application&#10;ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]&#10;&#10;# Labels pour la métadonnée&#10;LABEL maintainer=&quot;votre-email@exemple.com&quot;&#10;LABEL version=&quot;1.0&quot;&#10;LABEL description=&quot;Warhammer Battle Report API - Spring Boot Application&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/BattleReportController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/BattleReportController.java" />
              <option name="originalContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReport;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportRepository;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import com.example.restservice.repository.PlayerRepository;&#10;import io.github.cdimascio.dotenv.Dotenv;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import org.springframework.web.server.ResponseStatusException;&#10;import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;&#10;import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;&#10;import software.amazon.awssdk.regions.Region;&#10;import software.amazon.awssdk.services.s3.S3Client;&#10;import software.amazon.awssdk.services.s3.model.DeleteObjectRequest;&#10;import software.amazon.awssdk.services.s3.model.PutObjectRequest;&#10;import org.springframework.web.bind.annotation.RequestBody;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.sql.SQLException;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@CrossOrigin(origins = {&quot;http://localhost:5173&quot;, &quot;http://127.0.0.1:5173&quot;}, allowCredentials = &quot;true&quot;)&#10;public class BattleReportController {&#10;&#10;    private final Dotenv dotenv;&#10;    private final S3Client s3Client;&#10;    private final String bucketName = &quot;old-world-realms&quot;;&#10;    private static final String PHOTO_PREFIX = &quot;battle-report-photos/&quot;;&#10;&#10;    public BattleReportController() {&#10;        dotenv = Dotenv.load();&#10;        AwsBasicCredentials credentials = AwsBasicCredentials.create(&#10;                dotenv.get(&quot;ACCESS_KEY&quot;),&#10;                dotenv.get(&quot;SECRET_KEY&quot;)&#10;        );&#10;&#10;        this.s3Client = S3Client.builder()&#10;                .region(Region.of(&quot;fr-par&quot;))&#10;                .credentialsProvider(StaticCredentialsProvider.create(credentials))&#10;                .endpointOverride(URI.create(&quot;https://s3.fr-par.scw.cloud&quot;))&#10;                .build();&#10;    }&#10;&#10;    // ✅ Nouvelle méthode simplifiée et corrigée d'upload de fichiers&#10;    @PostMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;List&lt;String&gt;&gt; uploadBattleReportPhotos(&#10;            @PathVariable(&quot;id&quot;) int battleReportId,&#10;            @RequestParam(&quot;fileBattleReportPhoto&quot;) MultipartFile[] files&#10;    ) {&#10;        if (files == null || files.length == 0) {&#10;            return ResponseEntity.badRequest().body(List.of(&quot;Aucun fichier reçu.&quot;));&#10;        }&#10;&#10;        try {&#10;            List&lt;String&gt; uploadedNames = Arrays.stream(files)&#10;                    .filter(file -&gt; !file.isEmpty())&#10;                    .map(file -&gt; {&#10;                        try {&#10;                            String fileName = UUID.randomUUID().toString();&#10;&#10;                            // Upload vers S3&#10;                            s3Client.putObject(&#10;                                    PutObjectRequest.builder()&#10;                                            .bucket(bucketName)&#10;                                            .key(PHOTO_PREFIX + fileName)&#10;                                            .contentType(file.getContentType())&#10;                                            .build(),&#10;                                    software.amazon.awssdk.core.sync.RequestBody.fromInputStream(&#10;                                            file.getInputStream(), file.getSize())&#10;                            );&#10;&#10;                            // Enregistrement en base&#10;                            BattleReportPhoto photo = new BattleReportPhoto();&#10;                            photo.setNameBattleReportPhoto(fileName);&#10;                            photo.setBattleReport_idBattleReport(battleReportId);&#10;                            BattleReportPhotoRepository.create(photo);&#10;&#10;                            return fileName;&#10;                        } catch (IOException | SQLException e) {&#10;                            throw new RuntimeException(e);&#10;                        }&#10;                    })&#10;                    .collect(Collectors.toList());&#10;&#10;            return ResponseEntity.ok(uploadedNames);&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(List.of(&quot;Upload failed&quot;));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport&quot;)&#10;    public List&lt;BattleReport&gt; getBattleReports() {&#10;        try {&#10;            return BattleReportRepository.findAll();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return List.of(); // Plus moderne que Collections.emptyList()&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport/{id}&quot;)&#10;    public BattleReport getBattleReport(@PathVariable int id) {&#10;        try {&#10;            return BattleReportRepository.findById(id);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Battle Report not found with the Id : &quot; + id);&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport/user/{id}&quot;)&#10;    public List&lt;BattleReport&gt; getBattleReportByUserId(@PathVariable(&quot;id&quot;) String idUser) {&#10;        try {&#10;            return BattleReportRepository.findByUserId(idUser);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return List.of(); // Plus moderne que Collections.emptyList()&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/battlereport&quot;)&#10;    public BattleReport createBattleReport(@RequestBody BattleReport battleReport) {&#10;        try {&#10;            // ✅ CORRECTION: Supprimer la duplication - la création des photos est déjà gérée dans BattleReportRepository.create()&#10;            int idBattleReport = BattleReportRepository.create(battleReport);&#10;            return BattleReportRepository.findById(idBattleReport);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error creating battle report.&quot;);&#10;        }&#10;    }&#10;&#10;    @PutMapping(&quot;/battlereport/{id}&quot;)&#10;    public BattleReport updateBattleReport(@PathVariable int id, @RequestBody BattleReport battleReport) {&#10;        try {&#10;            int rows = BattleReportRepository.update(id, battleReport);&#10;            if (rows &gt; 0) {&#10;                return BattleReportRepository.findById(id);&#10;            } else {&#10;                throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Battle report not found.&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error updating battle report.&quot;);&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/battlereport/{id}&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteBattleReport(@PathVariable int id) {&#10;        try {&#10;            // Récupérer et supprimer les photos de S3 avec stream&#10;            BattleReportPhotoRepository.findByBattleReportId(id)&#10;                    .forEach(photo -&gt; {&#10;                        try {&#10;                            s3Client.deleteObject(DeleteObjectRequest.builder()&#10;                                    .bucket(bucketName)&#10;                                    .key(PHOTO_PREFIX + photo.getNameBattleReportPhoto())&#10;                                    .build()&#10;                            );&#10;                        } catch (Exception e) {&#10;                            // Log l'erreur mais continue la suppression&#10;                            e.printStackTrace();&#10;                        }&#10;                    });&#10;&#10;            BattleReportRepository.delete(id);&#10;            return ResponseEntity.ok(&quot;Rapport de bataille et ses images supprimés avec succès.&quot;);&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteBattleReportPhotos(&#10;            @PathVariable(&quot;id&quot;) int battleReportId,&#10;            @RequestBody List&lt;String&gt; photoFileNamesToDelete&#10;    ) {&#10;        if (photoFileNamesToDelete == null || photoFileNamesToDelete.isEmpty()) {&#10;            return ResponseEntity.badRequest().body(&quot;Aucun nom de fichier à supprimer.&quot;);&#10;        }&#10;&#10;        try {&#10;            photoFileNamesToDelete.forEach(fileName -&gt; {&#10;                try {&#10;                    // Supprimer l'image de S3&#10;                    s3Client.deleteObject(DeleteObjectRequest.builder()&#10;                            .bucket(bucketName)&#10;                            .key(PHOTO_PREFIX + fileName)&#10;                            .build()&#10;                    );&#10;&#10;                    // Supprimer l'entrée correspondante dans la base&#10;                    BattleReportPhoto photoToDelete = BattleReportPhotoRepository&#10;                            .findByFileNameAndBattleReportId(fileName, battleReportId);&#10;                    if (photoToDelete != null) {&#10;                        BattleReportPhotoRepository.delete(photoToDelete.getIdBattleReportPhoto());&#10;                    }&#10;                } catch (Exception e) {&#10;                    e.printStackTrace();&#10;                    throw new RuntimeException(&quot;Erreur lors de la suppression de &quot; + fileName, e);&#10;                }&#10;            });&#10;&#10;            return ResponseEntity.ok(&quot;Photos supprimées avec succès.&quot;);&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReport;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportRepository;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import com.example.restservice.service.S3Service;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import org.springframework.web.server.ResponseStatusException;&#10;&#10;import java.io.IOException;&#10;import java.sql.SQLException;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.UUID;&#10;import java.util.stream.Collectors;&#10;&#10;@RestController&#10;@CrossOrigin(origins = {&quot;http://localhost:5173&quot;, &quot;http://127.0.0.1:5173&quot;}, allowCredentials = &quot;true&quot;)&#10;public class BattleReportController {&#10;&#10;    private final S3Service s3Service;&#10;&#10;    public BattleReportController(S3Service s3Service) {&#10;        this.s3Service = s3Service;&#10;    }&#10;&#10;    // ✅ Nouvelle méthode simplifiée et corrigée d'upload de fichiers&#10;    @PostMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;List&lt;String&gt;&gt; uploadBattleReportPhotos(&#10;            @PathVariable(&quot;id&quot;) int battleReportId,&#10;            @RequestParam(&quot;fileBattleReportPhoto&quot;) MultipartFile[] files&#10;    ) {&#10;        if (files == null || files.length == 0) {&#10;            return ResponseEntity.badRequest().body(List.of(&quot;Aucun fichier reçu.&quot;));&#10;        }&#10;&#10;        try {&#10;            List&lt;String&gt; uploadedNames = Arrays.stream(files)&#10;                    .filter(file -&gt; !file.isEmpty())&#10;                    .map(file -&gt; {&#10;                        try {&#10;                            String fileName = UUID.randomUUID().toString();&#10;                            &#10;                            // Upload vers S3 via le service&#10;                            s3Service.uploadFile(fileName, file.getInputStream(), file.getSize(), file.getContentType());&#10;&#10;                            // Enregistrement en base&#10;                            BattleReportPhoto photo = new BattleReportPhoto();&#10;                            photo.setNameBattleReportPhoto(fileName);&#10;                            photo.setBattleReport_idBattleReport(battleReportId);&#10;                            BattleReportPhotoRepository.create(photo);&#10;&#10;                            return fileName;&#10;                        } catch (IOException | SQLException e) {&#10;                            throw new RuntimeException(e);&#10;                        }&#10;                    })&#10;                    .collect(Collectors.toList());&#10;&#10;            return ResponseEntity.ok(uploadedNames);&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(List.of(&quot;Upload failed&quot;));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport&quot;)&#10;    public List&lt;BattleReport&gt; getBattleReports() {&#10;        try {&#10;            return BattleReportRepository.findAll();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return List.of(); // Plus moderne que Collections.emptyList()&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport/{id}&quot;)&#10;    public BattleReport getBattleReport(@PathVariable int id) {&#10;        try {&#10;            return BattleReportRepository.findById(id);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Battle Report not found with the Id : &quot; + id);&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport/user/{id}&quot;)&#10;    public List&lt;BattleReport&gt; getBattleReportByUserId(@PathVariable(&quot;id&quot;) String idUser) {&#10;        try {&#10;            return BattleReportRepository.findByUserId(idUser);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return List.of(); // Plus moderne que Collections.emptyList()&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/battlereport&quot;)&#10;    public BattleReport createBattleReport(@RequestBody BattleReport battleReport) {&#10;        try {&#10;            // ✅ CORRECTION: Supprimer la duplication - la création des photos est déjà gérée dans BattleReportRepository.create()&#10;            int idBattleReport = BattleReportRepository.create(battleReport);&#10;            return BattleReportRepository.findById(idBattleReport);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error creating battle report.&quot;);&#10;        }&#10;    }&#10;&#10;    @PutMapping(&quot;/battlereport/{id}&quot;)&#10;    public BattleReport updateBattleReport(@PathVariable int id, @RequestBody BattleReport battleReport) {&#10;        try {&#10;            int rows = BattleReportRepository.update(id, battleReport);&#10;            if (rows &gt; 0) {&#10;                return BattleReportRepository.findById(id);&#10;            } else {&#10;                throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Battle report not found.&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, &quot;Error updating battle report.&quot;);&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/battlereport/{id}&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteBattleReport(@PathVariable int id) {&#10;        try {&#10;            // Récupérer et supprimer les photos de S3 avec le service&#10;            BattleReportPhotoRepository.findByBattleReportId(id)&#10;                    .forEach(photo -&gt; {&#10;                        try {&#10;                            s3Service.deleteFile(photo.getNameBattleReportPhoto());&#10;                        } catch (Exception e) {&#10;                            // Log l'erreur mais continue la suppression&#10;                            e.printStackTrace();&#10;                        }&#10;                    });&#10;&#10;            BattleReportRepository.delete(id);&#10;            return ResponseEntity.ok(&quot;Rapport de bataille et ses images supprimés avec succès.&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteBattleReportPhotos(&#10;            @PathVariable(&quot;id&quot;) int battleReportId,&#10;            @RequestBody List&lt;String&gt; photoFileNamesToDelete&#10;    ) {&#10;        if (photoFileNamesToDelete == null || photoFileNamesToDelete.isEmpty()) {&#10;            return ResponseEntity.badRequest().body(&quot;Aucun nom de fichier à supprimer.&quot;);&#10;        }&#10;&#10;        try {&#10;            photoFileNamesToDelete.forEach(fileName -&gt; {&#10;                try {&#10;                    // Supprimer l'image de S3 via le service&#10;                    s3Service.deleteFile(fileName);&#10;&#10;                    // Supprimer l'entrée correspondante dans la base&#10;                    BattleReportPhoto photoToDelete = BattleReportPhotoRepository&#10;                            .findByFileNameAndBattleReportId(fileName, battleReportId);&#10;                    if (photoToDelete != null) {&#10;                        BattleReportPhotoRepository.delete(photoToDelete.getIdBattleReportPhoto());&#10;                    }&#10;                } catch (Exception e) {&#10;                    e.printStackTrace();&#10;                    throw new RuntimeException(&quot;Erreur lors de la suppression de &quot; + fileName, e);&#10;                }&#10;            });&#10;&#10;            return ResponseEntity.ok(&quot;Photos supprimées avec succès.&quot;);&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/ImageUploadController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/ImageUploadController.java" />
              <option name="originalContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import io.github.cdimascio.dotenv.Dotenv;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;&#10;import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;&#10;import software.amazon.awssdk.core.ResponseBytes;&#10;import software.amazon.awssdk.core.sync.RequestBody;&#10;import software.amazon.awssdk.regions.Region;&#10;import software.amazon.awssdk.services.s3.S3Client;&#10;import software.amazon.awssdk.services.s3.model.*;&#10;import software.amazon.awssdk.services.s3.presigner.S3Presigner;&#10;import software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest;&#10;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.sql.SQLException;&#10;import java.time.Duration;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@RestController&#10;public class ImageUploadController {&#10;&#10;    private final Dotenv dotenv;&#10;    private final S3Client s3Client;&#10;    private final S3Presigner s3Presigner;&#10;    private final String bucketName = &quot;old-world-realms&quot;;&#10;    private static final String PHOTO_PREFIX = &quot;battle-report-photos/&quot;;&#10;&#10;    public ImageUploadController() {&#10;        dotenv = Dotenv.load();&#10;        AwsBasicCredentials credentials = AwsBasicCredentials.create(&#10;                dotenv.get(&quot;ACCESS_KEY&quot;),&#10;                dotenv.get(&quot;SECRET_KEY&quot;)&#10;        );&#10;&#10;        this.s3Client = S3Client.builder()&#10;                .region(Region.of(&quot;fr-par&quot;))&#10;                .credentialsProvider(StaticCredentialsProvider.create(credentials))&#10;                .endpointOverride(URI.create(&quot;https://s3.fr-par.scw.cloud&quot;))&#10;                .build();&#10;&#10;        this.s3Presigner = S3Presigner.builder()&#10;                .region(Region.of(&quot;fr-par&quot;))&#10;                .credentialsProvider(StaticCredentialsProvider.create(credentials))&#10;                .endpointOverride(URI.create(&quot;https://s3.fr-par.scw.cloud&quot;))&#10;                .build();&#10;    }&#10;&#10;    @PostMapping(&quot;/upload&quot;)&#10;    public ResponseEntity&lt;String&gt; uploadImage(&#10;            @RequestParam(&quot;file&quot;) MultipartFile file,&#10;            @RequestParam(&quot;battleReportId&quot;) int battleReportId) {&#10;        try {&#10;            String uuidFileName = UUID.randomUUID() + &quot;-&quot; + file.getOriginalFilename();&#10;&#10;            s3Client.putObject(&#10;                    PutObjectRequest.builder()&#10;                            .bucket(bucketName)&#10;                            .key(PHOTO_PREFIX + uuidFileName)&#10;                            .contentType(file.getContentType())&#10;                            .build(),&#10;                    RequestBody.fromInputStream(file.getInputStream(), file.getSize())&#10;            );&#10;&#10;            BattleReportPhoto photo = new BattleReportPhoto();&#10;            photo.setNameBattleReportPhoto(uuidFileName);&#10;            photo.setBattleReport_idBattleReport(battleReportId);&#10;            photo.setIdBattleReportPhoto(BattleReportPhotoRepository.create(photo));&#10;&#10;            return ResponseEntity.ok(uuidFileName);&#10;        } catch (IOException | SQLException e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Upload failed&quot;);&#10;        }&#10;    }&#10;&#10;&#10;    @GetMapping(&quot;/download/{filename}&quot;)&#10;    public ResponseEntity&lt;byte[]&gt; downloadImage(@PathVariable String filename) {&#10;        try {&#10;            ResponseBytes&lt;GetObjectResponse&gt; response = s3Client.getObjectAsBytes(&#10;                    GetObjectRequest.builder()&#10;                            .bucket(bucketName)&#10;                            .key(PHOTO_PREFIX + filename)&#10;                            .build()&#10;            );&#10;&#10;            return ResponseEntity.ok()&#10;                    .contentType(MediaType.IMAGE_JPEG)&#10;                    .body(response.asByteArray());&#10;&#10;        } catch (S3Exception e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);&#10;        }&#10;    }&#10;&#10;&#10;    @DeleteMapping(&quot;/delete/{filename}&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteImage(@PathVariable String filename) {&#10;        try {&#10;            s3Client.deleteObject(&#10;                    DeleteObjectRequest.builder()&#10;                            .bucket(bucketName)&#10;                            .key(PHOTO_PREFIX + filename)&#10;                            .build()&#10;            );&#10;&#10;            return ResponseEntity.ok(&quot;Image supprimée : &quot; + filename);&#10;        } catch (S3Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.awsErrorDetails().errorMessage());&#10;        }&#10;    }&#10;&#10;&#10;    @GetMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;List&lt;BattleReportPhoto&gt;&gt; getPhotosForBattleReport(@PathVariable int id) {&#10;        try {&#10;            return ResponseEntity.ok(BattleReportPhotoRepository.findByBattleReportId(id));&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/image-url/{filename}&quot;)&#10;    public ResponseEntity&lt;String&gt; getPresignedUrl(@PathVariable String filename) {&#10;        try {&#10;            PresignedGetObjectRequest presignedRequest = s3Presigner.presignGetObject(r -&gt; r&#10;                    .signatureDuration(Duration.ofMinutes(15))&#10;                    .getObjectRequest(GetObjectRequest.builder()&#10;                            .bucket(bucketName)&#10;                            .key(PHOTO_PREFIX + filename)&#10;                            .build())&#10;            );&#10;&#10;            return ResponseEntity.ok(presignedRequest.url().toString());&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Erreur : &quot; + e.getMessage());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import com.example.restservice.service.S3Service;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import software.amazon.awssdk.core.ResponseBytes;&#10;import software.amazon.awssdk.services.s3.model.GetObjectResponse;&#10;import software.amazon.awssdk.services.s3.model.S3Exception;&#10;&#10;import java.io.IOException;&#10;import java.sql.SQLException;&#10;import java.time.Duration;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;@RestController&#10;public class ImageUploadController {&#10;&#10;    private final S3Service s3Service;&#10;&#10;    public ImageUploadController(S3Service s3Service) {&#10;        this.s3Service = s3Service;&#10;    }&#10;&#10;    @PostMapping(&quot;/upload&quot;)&#10;    public ResponseEntity&lt;String&gt; uploadImage(&#10;            @RequestParam(&quot;file&quot;) MultipartFile file,&#10;            @RequestParam(&quot;battleReportId&quot;) int battleReportId) {&#10;        try {&#10;            String uuidFileName = UUID.randomUUID() + &quot;-&quot; + file.getOriginalFilename();&#10;&#10;            s3Service.uploadFile(uuidFileName, file.getInputStream(), file.getSize(), file.getContentType());&#10;&#10;            BattleReportPhoto photo = new BattleReportPhoto();&#10;            photo.setNameBattleReportPhoto(uuidFileName);&#10;            photo.setBattleReport_idBattleReport(battleReportId);&#10;            photo.setIdBattleReportPhoto(BattleReportPhotoRepository.create(photo));&#10;&#10;            return ResponseEntity.ok(uuidFileName);&#10;        } catch (IOException | SQLException e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Upload failed&quot;);&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/download/{filename}&quot;)&#10;    public ResponseEntity&lt;byte[]&gt; downloadImage(@PathVariable String filename) {&#10;        try {&#10;            ResponseBytes&lt;GetObjectResponse&gt; response = s3Service.downloadFile(filename);&#10;&#10;            return ResponseEntity.ok()&#10;                    .contentType(MediaType.IMAGE_JPEG)&#10;                    .body(response.asByteArray());&#10;&#10;        } catch (S3Exception e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{filename}&quot;)&#10;    public ResponseEntity&lt;String&gt; deleteImage(@PathVariable String filename) {&#10;        try {&#10;            s3Service.deleteFile(filename);&#10;            return ResponseEntity.ok(&quot;Image supprimée : &quot; + filename);&#10;        } catch (S3Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Erreur lors de la suppression : &quot; + e.awsErrorDetails().errorMessage());&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/battlereport/{id}/photos&quot;)&#10;    public ResponseEntity&lt;List&lt;BattleReportPhoto&gt;&gt; getPhotosForBattleReport(@PathVariable int id) {&#10;        try {&#10;            return ResponseEntity.ok(BattleReportPhotoRepository.findByBattleReportId(id));&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/image-url/{filename}&quot;)&#10;    public ResponseEntity&lt;String&gt; getPresignedUrl(@PathVariable String filename) {&#10;        try {&#10;            String presignedUrl = s3Service.getPresignedUrl(filename);&#10;            return ResponseEntity.ok(presignedUrl);&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Erreur : &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/PlayerController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/controller/PlayerController.java" />
              <option name="originalContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.Player;&#10;import com.example.restservice.repository.PlayerRepository;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.server.ResponseStatusException;&#10;&#10;import java.sql.SQLException;&#10;import java.util.Collections;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;public class PlayerController {&#10;    @GetMapping(&quot;/player&quot;)&#10;    public List&lt;Player&gt; getPlayers() {&#10;        try {&#10;            return PlayerRepository.findAll();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Collections.emptyList();&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/player/{id}&quot;)&#10;    public Player getPlayer(@PathVariable int id) {&#10;        try {&#10;            return PlayerRepository.findById(id);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Player not found with the Id : &quot; + id);&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/player&quot;)&#10;    public @ResponseBody Map&lt;String, Object&gt; createPlayer(@RequestBody Player player) {&#10;        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();&#10;        try {&#10;            int generatedId = PlayerRepository.create(player); // on suppose que cette méthode renvoie l'id du joueur&#10;            if (generatedId &gt; 0) {&#10;                response.put(&quot;message&quot;, &quot;Player created successfully.&quot;);&#10;                response.put(&quot;idPlayer&quot;, generatedId);&#10;            } else {&#10;                response.put(&quot;message&quot;, &quot;Failed to create player.&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            response.put(&quot;message&quot;, &quot;Error creating player.&quot;);&#10;        }&#10;        return response;&#10;    }&#10;&#10;&#10;    @PutMapping(&quot;/player/{id}&quot;)&#10;    public @ResponseBody Map&lt;String, String&gt; updatePlayer(@PathVariable int id, @RequestBody Player player) {&#10;        try {&#10;            int rows = PlayerRepository.update(id, player);&#10;            return Collections.singletonMap(&quot;message&quot;,&#10;                    rows &gt; 0 ? &quot;Player updated successfully.&quot; : &quot;Player not found.&quot;);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Collections.singletonMap(&quot;message&quot;, &quot;Error updating player.&quot;);&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/player/{id}&quot;)&#10;    public @ResponseBody Map&lt;String, String&gt; deletePlayer(@PathVariable int id) {&#10;        try {&#10;            int rows = PlayerRepository.delete(id);&#10;            return Collections.singletonMap(&quot;message&quot;,&#10;                    rows &gt; 0 ? &quot;Player deleted successfully.&quot; : &quot;Player not found.&quot;);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Collections.singletonMap(&quot;message&quot;, &quot;Error deleting player.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.Player;&#10;import com.example.restservice.repository.PlayerRepository;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.server.ResponseStatusException;&#10;&#10;import java.sql.SQLException;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;public class PlayerController {&#10;    @GetMapping(&quot;/player&quot;)&#10;    public List&lt;Player&gt; getPlayers() {&#10;        try {&#10;            return PlayerRepository.findAll();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return List.of(); // Plus moderne que Collections.emptyList()&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/player/{id}&quot;)&#10;    public Player getPlayer(@PathVariable int id) {&#10;        try {&#10;            return PlayerRepository.findById(id);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Player not found with the Id : &quot; + id);&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/player&quot;)&#10;    public @ResponseBody Map&lt;String, Object&gt; createPlayer(@RequestBody Player player) {&#10;        try {&#10;            int generatedId = PlayerRepository.create(player);&#10;            if (generatedId &gt; 0) {&#10;                return Map.of(&#10;                    &quot;message&quot;, &quot;Player created successfully.&quot;,&#10;                    &quot;idPlayer&quot;, generatedId&#10;                );&#10;            } else {&#10;                return Map.of(&quot;message&quot;, &quot;Failed to create player.&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Map.of(&quot;message&quot;, &quot;Error creating player.&quot;);&#10;        }&#10;    }&#10;&#10;    @PutMapping(&quot;/player/{id}&quot;)&#10;    public @ResponseBody Map&lt;String, String&gt; updatePlayer(@PathVariable int id, @RequestBody Player player) {&#10;        try {&#10;            int rows = PlayerRepository.update(id, player);&#10;            return Map.of(&quot;message&quot;, &#10;                rows &gt; 0 ? &quot;Player updated successfully.&quot; : &quot;Player not found.&quot;);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Map.of(&quot;message&quot;, &quot;Error updating player.&quot;);&#10;        }&#10;    }&#10;&#10;    @DeleteMapping(&quot;/player/{id}&quot;)&#10;    public @ResponseBody Map&lt;String, String&gt; deletePlayer(@PathVariable int id) {&#10;        try {&#10;            int rows = PlayerRepository.delete(id);&#10;            return Map.of(&quot;message&quot;,&#10;                rows &gt; 0 ? &quot;Player deleted successfully.&quot; : &quot;Player not found.&quot;);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;            return Map.of(&quot;message&quot;, &quot;Error deleting player.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/BattleReportPhotoRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/BattleReportPhotoRepository.java" />
              <option name="originalContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import org.apache.commons.dbutils.QueryRunner;&#10;import org.apache.commons.dbutils.ResultSetHandler;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.sql.Statement;&#10;import java.util.List;&#10;&#10;public class BattleReportPhotoRepository {&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;&#10;    public static List&lt;BattleReportPhoto&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;BattleReportPhoto&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(BattleReportPhoto.class);&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM battlereportphoto&quot;, resultHandler);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReportPhoto findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;BattleReportPhoto&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(BattleReportPhoto.class);&#10;            try {&#10;                List&lt;BattleReportPhoto&gt; photos = queryRunner.query(conn, &quot;SELECT * FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;, resultHandler, id);&#10;                return photos.isEmpty() ? null : photos.get(0);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;BattleReportPhoto&gt; findByBattleReportId(int idBattleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;BattleReportPhoto&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(BattleReportPhoto.class);&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;, resultHandler, idBattleReport);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Méthode pour utiliser une connexion existante&#10;    public static List&lt;BattleReportPhoto&gt; findByBattleReportId(int idBattleReport, Connection conn) throws SQLException {&#10;        ResultSetHandler&lt;List&lt;BattleReportPhoto&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(BattleReportPhoto.class);&#10;        return queryRunner.query(conn, &quot;SELECT * FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;, resultHandler, idBattleReport);&#10;    }&#10;&#10;    public static int create(BattleReportPhoto photo) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return create(photo, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int create(BattleReportPhoto photo, Connection conn) throws SQLException {&#10;        String sql = &quot;INSERT INTO battlereportphoto (nameBattleReportPhoto, battleReport_idBattleReport) VALUES (?, ?)&quot;;&#10;        try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            stmt.setString(1, photo.getNameBattleReportPhoto());&#10;            stmt.setInt(2, photo.getBattleReport_idBattleReport());&#10;&#10;            int affectedRows = stmt.executeUpdate();&#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;Creating BattleReportPhoto failed, no rows affected.&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    return generatedKeys.getInt(1);&#10;                } else {&#10;                    throw new SQLException(&quot;Creating BattleReportPhoto failed, no ID obtained.&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static int update(int id, BattleReportPhoto photo) throws SQLException {&#10;        String sql = &quot;UPDATE battlereportphoto SET nameBattleReportPhoto = ?, battleReport_idBattleReport = ? WHERE idBattleReportPhoto = ?&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, sql,&#10;                        photo.getNameBattleReportPhoto(),&#10;                        photo.getBattleReport_idBattleReport(),&#10;                        id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int deleteByBattleReportId(int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return deleteByBattleReportId(battleReportId, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int deleteByBattleReportId(int battleReportId, Connection conn) throws SQLException {&#10;        return queryRunner.update(conn,&#10;                &quot;DELETE FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;,&#10;                battleReportId);&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, &quot;DELETE FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;, id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReportPhoto findByFileNameAndBattleReportId(String fileName, int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            String query = &quot;SELECT * FROM battlereportphoto WHERE nameBattleReportPhoto = ? AND battleReport_idBattleReport = ?&quot;;&#10;            try (PreparedStatement stmt = conn.prepareStatement(query)) {&#10;                stmt.setString(1, fileName);&#10;                stmt.setInt(2, battleReportId);&#10;                try (ResultSet rs = stmt.executeQuery()) {&#10;                    if (rs.next()) {&#10;                        return new BattleReportPhoto(&#10;                                rs.getInt(&quot;idBattleReportPhoto&quot;),&#10;                                rs.getString(&quot;nameBattleReportPhoto&quot;),&#10;                                rs.getInt(&quot;battleReport_idBattleReport&quot;)&#10;                        );&#10;                    } else {&#10;                        return null;&#10;                    }&#10;                }&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import org.apache.commons.dbutils.QueryRunner;&#10;import org.apache.commons.dbutils.ResultSetHandler;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.SQLException;&#10;import java.sql.Statement;&#10;import java.util.List;&#10;&#10;public class BattleReportPhotoRepository {&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;    &#10;    // Handler réutilisable pour éviter la duplication&#10;    private static final ResultSetHandler&lt;List&lt;BattleReportPhoto&gt;&gt; listHandler = &#10;            new BeanListHandler&lt;&gt;(BattleReportPhoto.class);&#10;&#10;    public static List&lt;BattleReportPhoto&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM battlereportphoto&quot;, listHandler);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReportPhoto findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReportPhoto&gt; photos = queryRunner.query(conn, &#10;                    &quot;SELECT * FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;, &#10;                    listHandler, id);&#10;                return photos.isEmpty() ? null : photos.get(0);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;BattleReportPhoto&gt; findByBattleReportId(int idBattleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.query(conn, &#10;                    &quot;SELECT * FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;, &#10;                    listHandler, idBattleReport);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Méthode pour utiliser une connexion existante&#10;    public static List&lt;BattleReportPhoto&gt; findByBattleReportId(int idBattleReport, Connection conn) throws SQLException {&#10;        return queryRunner.query(conn, &#10;            &quot;SELECT * FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;, &#10;            listHandler, idBattleReport);&#10;    }&#10;&#10;    public static int create(BattleReportPhoto photo) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return create(photo, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int create(BattleReportPhoto photo, Connection conn) throws SQLException {&#10;        String sql = &quot;INSERT INTO battlereportphoto (nameBattleReportPhoto, battleReport_idBattleReport) VALUES (?, ?)&quot;;&#10;        try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            stmt.setString(1, photo.getNameBattleReportPhoto());&#10;            stmt.setInt(2, photo.getBattleReport_idBattleReport());&#10;&#10;            int affectedRows = stmt.executeUpdate();&#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;Creating BattleReportPhoto failed, no rows affected.&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    return generatedKeys.getInt(1);&#10;                } else {&#10;                    throw new SQLException(&quot;Creating BattleReportPhoto failed, no ID obtained.&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static int update(int id, BattleReportPhoto photo) throws SQLException {&#10;        String sql = &quot;UPDATE battlereportphoto SET nameBattleReportPhoto = ?, battleReport_idBattleReport = ? WHERE idBattleReportPhoto = ?&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, sql,&#10;                    photo.getNameBattleReportPhoto(),&#10;                    photo.getBattleReport_idBattleReport(),&#10;                    id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int deleteByBattleReportId(int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return deleteByBattleReportId(battleReportId, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int deleteByBattleReportId(int battleReportId, Connection conn) throws SQLException {&#10;        return queryRunner.update(conn,&#10;                &quot;DELETE FROM battlereportphoto WHERE battleReport_idBattleReport = ?&quot;,&#10;                battleReportId);&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, &quot;DELETE FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;, id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReportPhoto findByFileNameAndBattleReportId(String fileName, int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReportPhoto&gt; photos = queryRunner.query(conn,&#10;                    &quot;SELECT * FROM battlereportphoto WHERE nameBattleReportPhoto = ? AND battleReport_idBattleReport = ?&quot;,&#10;                    listHandler, fileName, battleReportId);&#10;                    &#10;                return photos.isEmpty() ? null : photos.get(0);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/BattleReportRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/BattleReportRepository.java" />
              <option name="originalContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.BattleReport;&#10;import com.example.restservice.model.Player;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import org.apache.commons.dbutils.*;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.SQLException;&#10;import java.util.*;&#10;&#10;public class BattleReportRepository {&#10;&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;&#10;    // Mapper de noms snake_case (SQL) vers camelCase (Java)&#10;    private static final Map&lt;String, String&gt; columnToPropertyOverrides = new HashMap&lt;&gt;();&#10;    static {&#10;        columnToPropertyOverrides.put(&quot;idBattleReport&quot;, &quot;idBattleReport&quot;);&#10;        columnToPropertyOverrides.put(&quot;nameBattleReport&quot;, &quot;nameBattleReport&quot;);&#10;        columnToPropertyOverrides.put(&quot;descriptionBattleReport&quot;, &quot;descriptionBattleReport&quot;);&#10;        columnToPropertyOverrides.put(&quot;scenario_idScenario&quot;, &quot;scenario_idScenario&quot;);&#10;        columnToPropertyOverrides.put(&quot;armyPoints&quot;, &quot;armyPoints&quot;);&#10;        columnToPropertyOverrides.put(&quot;idUser&quot;, &quot;idUser&quot;);&#10;    }&#10;&#10;    private static final RowProcessor rowProcessor =&#10;            new BasicRowProcessor(new BeanProcessor(columnToPropertyOverrides));&#10;&#10;    private static final ResultSetHandler&lt;List&lt;BattleReport&gt;&gt; battleReportListHandler =&#10;            new BeanListHandler&lt;&gt;(BattleReport.class, rowProcessor);&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;&#10;    // Méthode utilitaire pour enrichir un BattleReport avec ses players et photos&#10;    private static void enrichBattleReport(BattleReport report) throws SQLException {&#10;        List&lt;Player&gt; players = PlayerRepository.findByBattleReportId(report.getIdBattleReport());&#10;        report.setPlayers(players);&#10;&#10;        List&lt;BattleReportPhoto&gt; photos = BattleReportPhotoRepository.findByBattleReportId(report.getIdBattleReport());&#10;        List&lt;String&gt; fileNames = photos.stream()&#10;                .map(BattleReportPhoto::getNameBattleReportPhoto)&#10;                .toList();&#10;        report.setPhotoFileNames(fileNames);&#10;    }&#10;&#10;    public static List&lt;BattleReport&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn, &quot;SELECT * FROM battlereport&quot;, battleReportListHandler);&#10;&#10;                reports.forEach(report -&gt; {&#10;                    try {&#10;                        enrichBattleReport(report);&#10;                    } catch (SQLException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                });&#10;&#10;                return reports;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReport findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn,&#10;                        &quot;SELECT * FROM battlereport WHERE idBattleReport = ?&quot;,&#10;                        battleReportListHandler,&#10;                        id);&#10;&#10;                if (reports == null || reports.isEmpty()) {&#10;                    return null;&#10;                }&#10;&#10;                BattleReport report = reports.get(0);&#10;                enrichBattleReport(report);&#10;                return report;&#10;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;BattleReport&gt; findByUserId(String idUser) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn,&#10;                        &quot;SELECT * FROM battlereport WHERE idUser = ?&quot;,&#10;                        battleReportListHandler,&#10;                        idUser);&#10;&#10;                if (reports == null) {&#10;                    return new ArrayList&lt;&gt;();&#10;                }&#10;&#10;                reports.forEach(report -&gt; {&#10;                    try {&#10;                        enrichBattleReport(report);&#10;                    } catch (SQLException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                });&#10;&#10;                return reports;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int create(BattleReport battleReport) throws SQLException {&#10;        String sql = &quot;INSERT INTO battlereport (nameBattleReport, descriptionBattleReport, scenario_idScenario, armyPoints, idUser) VALUES (?, ?, ?, ?, ?)&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                int affectedRows = queryRunner.update(conn, sql,&#10;                        battleReport.getNameBattleReport(),&#10;                        battleReport.getDescriptionBattleReport(),&#10;                        battleReport.getScenario_idScenario(),&#10;                        battleReport.getArmyPoints(),&#10;                        battleReport.getIdUser());&#10;&#10;                if (affectedRows == 0) {&#10;                    throw new SQLException(&quot;Creating BattleReport failed, no rows affected.&quot;);&#10;                }&#10;&#10;                int idBattleReport = queryRunner.query(conn, &quot;SELECT LAST_INSERT_ID()&quot;, rs -&gt; {&#10;                    rs.next();&#10;                    return rs.getInt(1);&#10;                });&#10;&#10;                // Simplification avec Optional et forEach&#10;                Optional.ofNullable(battleReport.getPlayers())&#10;                        .ifPresent(players -&gt; players.forEach(player -&gt; {&#10;                            try {&#10;                                player.setBattleReport_idBattleReport(idBattleReport);&#10;                                PlayerRepository.create(player, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                Optional.ofNullable(battleReport.getPhotoFileNames())&#10;                        .ifPresent(fileNames -&gt; fileNames.forEach(fileName -&gt; {&#10;                            try {&#10;                                BattleReportPhoto photo = new BattleReportPhoto();&#10;                                photo.setBattleReport_idBattleReport(idBattleReport);&#10;                                photo.setNameBattleReportPhoto(fileName);&#10;                                BattleReportPhotoRepository.create(photo, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                conn.commit();&#10;                return idBattleReport;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int update(int id, BattleReport battleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                String sql = &quot;UPDATE battlereport SET nameBattleReport = ?, descriptionBattleReport = ?, scenario_idScenario = ?, armyPoints = ?, idUser = ? WHERE idBattleReport = ?&quot;;&#10;                int updatedRows = queryRunner.update(conn, sql,&#10;                        battleReport.getNameBattleReport(),&#10;                        battleReport.getDescriptionBattleReport(),&#10;                        battleReport.getScenario_idScenario(),&#10;                        battleReport.getArmyPoints(),&#10;                        battleReport.getIdUser(),&#10;                        id);&#10;&#10;                // Gestion des joueurs avec Optional et forEach&#10;                PlayerRepository.deleteByBattleReportId(id, conn);&#10;                Optional.ofNullable(battleReport.getPlayers())&#10;                        .ifPresent(players -&gt; players.forEach(player -&gt; {&#10;                            try {&#10;                                player.setBattleReport_idBattleReport(id);&#10;                                PlayerRepository.create(player, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                // Gestion intelligente des photos simplifiée&#10;                List&lt;BattleReportPhoto&gt; existingPhotos = BattleReportPhotoRepository.findByBattleReportId(id);&#10;                List&lt;String&gt; existingFileNames = existingPhotos.stream()&#10;                        .map(BattleReportPhoto::getNameBattleReportPhoto)&#10;                        .toList();&#10;&#10;                List&lt;String&gt; newFileNames = Optional.ofNullable(battleReport.getPhotoFileNames())&#10;                        .orElse(new ArrayList&lt;&gt;());&#10;&#10;                // Ne supprimer que si la liste newFileNames n'est pas vide&#10;                if (!newFileNames.isEmpty()) {&#10;                    // Supprimer les photos qui ne sont plus dans la nouvelle liste&#10;                    existingPhotos.stream()&#10;                            .filter(photo -&gt; !newFileNames.contains(photo.getNameBattleReportPhoto()))&#10;                            .forEach(photo -&gt; {&#10;                                try {&#10;                                    queryRunner.update(conn, &quot;DELETE FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;,&#10;                                            photo.getIdBattleReportPhoto());&#10;                                } catch (SQLException e) {&#10;                                    throw new RuntimeException(e);&#10;                                }&#10;                            });&#10;&#10;                    // Ajouter les nouvelles photos qui n'existaient pas&#10;                    newFileNames.stream()&#10;                            .filter(fileName -&gt; !existingFileNames.contains(fileName))&#10;                            .forEach(fileName -&gt; {&#10;                                try {&#10;                                    BattleReportPhoto photo = new BattleReportPhoto();&#10;                                    photo.setBattleReport_idBattleReport(id);&#10;                                    photo.setNameBattleReportPhoto(fileName);&#10;                                    BattleReportPhotoRepository.create(photo, conn);&#10;                                } catch (SQLException e) {&#10;                                    throw new RuntimeException(e);&#10;                                }&#10;                            });&#10;                }&#10;&#10;                conn.commit();&#10;                return updatedRows;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                // Supprimer d'abord les dépendances dans une transaction&#10;                PlayerRepository.deleteByBattleReportId(id, conn);&#10;                BattleReportPhotoRepository.deleteByBattleReportId(id, conn);&#10;&#10;                // Puis supprimer le rapport principal&#10;                int result = queryRunner.update(conn, &quot;DELETE FROM battlereport WHERE idBattleReport = ?&quot;, id);&#10;&#10;                conn.commit();&#10;                return result;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.BattleReport;&#10;import com.example.restservice.model.Player;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import org.apache.commons.dbutils.*;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.SQLException;&#10;import java.util.*;&#10;&#10;public class BattleReportRepository {&#10;&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;&#10;    // Handler simplifié sans mapping inutile&#10;    private static final ResultSetHandler&lt;List&lt;BattleReport&gt;&gt; battleReportListHandler =&#10;            new BeanListHandler&lt;&gt;(BattleReport.class);&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;&#10;    // Méthode utilitaire pour enrichir un BattleReport avec ses players et photos&#10;    private static void enrichBattleReport(BattleReport report) throws SQLException {&#10;        List&lt;Player&gt; players = PlayerRepository.findByBattleReportId(report.getIdBattleReport());&#10;        report.setPlayers(players);&#10;&#10;        List&lt;BattleReportPhoto&gt; photos = BattleReportPhotoRepository.findByBattleReportId(report.getIdBattleReport());&#10;        List&lt;String&gt; fileNames = photos.stream()&#10;                .map(BattleReportPhoto::getNameBattleReportPhoto)&#10;                .toList();&#10;        report.setPhotoFileNames(fileNames);&#10;    }&#10;&#10;    public static List&lt;BattleReport&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn, &quot;SELECT * FROM battlereport&quot;, battleReportListHandler);&#10;&#10;                reports.forEach(report -&gt; {&#10;                    try {&#10;                        enrichBattleReport(report);&#10;                    } catch (SQLException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                });&#10;&#10;                return reports;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static BattleReport findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn,&#10;                        &quot;SELECT * FROM battlereport WHERE idBattleReport = ?&quot;,&#10;                        battleReportListHandler,&#10;                        id);&#10;&#10;                if (reports == null || reports.isEmpty()) {&#10;                    return null;&#10;                }&#10;&#10;                BattleReport report = reports.get(0);&#10;                enrichBattleReport(report);&#10;                return report;&#10;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;BattleReport&gt; findByUserId(String idUser) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;BattleReport&gt; reports = queryRunner.query(conn,&#10;                        &quot;SELECT * FROM battlereport WHERE idUser = ?&quot;,&#10;                        battleReportListHandler,&#10;                        idUser);&#10;&#10;                if (reports == null) {&#10;                    return new ArrayList&lt;&gt;();&#10;                }&#10;&#10;                reports.forEach(report -&gt; {&#10;                    try {&#10;                        enrichBattleReport(report);&#10;                    } catch (SQLException e) {&#10;                        throw new RuntimeException(e);&#10;                    }&#10;                });&#10;&#10;                return reports;&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int create(BattleReport battleReport) throws SQLException {&#10;        String sql = &quot;INSERT INTO battlereport (nameBattleReport, descriptionBattleReport, scenario_idScenario, armyPoints, idUser) VALUES (?, ?, ?, ?, ?)&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                int affectedRows = queryRunner.update(conn, sql,&#10;                        battleReport.getNameBattleReport(),&#10;                        battleReport.getDescriptionBattleReport(),&#10;                        battleReport.getScenario_idScenario(),&#10;                        battleReport.getArmyPoints(),&#10;                        battleReport.getIdUser());&#10;&#10;                if (affectedRows == 0) {&#10;                    throw new SQLException(&quot;Creating BattleReport failed, no rows affected.&quot;);&#10;                }&#10;&#10;                int idBattleReport = queryRunner.query(conn, &quot;SELECT LAST_INSERT_ID()&quot;, rs -&gt; {&#10;                    rs.next();&#10;                    return rs.getInt(1);&#10;                });&#10;&#10;                // Simplification avec Optional et forEach&#10;                Optional.ofNullable(battleReport.getPlayers())&#10;                        .ifPresent(players -&gt; players.forEach(player -&gt; {&#10;                            try {&#10;                                player.setBattleReport_idBattleReport(idBattleReport);&#10;                                PlayerRepository.create(player, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                Optional.ofNullable(battleReport.getPhotoFileNames())&#10;                        .ifPresent(fileNames -&gt; fileNames.forEach(fileName -&gt; {&#10;                            try {&#10;                                BattleReportPhoto photo = new BattleReportPhoto();&#10;                                photo.setBattleReport_idBattleReport(idBattleReport);&#10;                                photo.setNameBattleReportPhoto(fileName);&#10;                                BattleReportPhotoRepository.create(photo, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                conn.commit();&#10;                return idBattleReport;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int update(int id, BattleReport battleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                String sql = &quot;UPDATE battlereport SET nameBattleReport = ?, descriptionBattleReport = ?, scenario_idScenario = ?, armyPoints = ?, idUser = ? WHERE idBattleReport = ?&quot;;&#10;                int updatedRows = queryRunner.update(conn, sql,&#10;                        battleReport.getNameBattleReport(),&#10;                        battleReport.getDescriptionBattleReport(),&#10;                        battleReport.getScenario_idScenario(),&#10;                        battleReport.getArmyPoints(),&#10;                        battleReport.getIdUser(),&#10;                        id);&#10;&#10;                // Gestion des joueurs avec Optional et forEach&#10;                PlayerRepository.deleteByBattleReportId(id, conn);&#10;                Optional.ofNullable(battleReport.getPlayers())&#10;                        .ifPresent(players -&gt; players.forEach(player -&gt; {&#10;                            try {&#10;                                player.setBattleReport_idBattleReport(id);&#10;                                PlayerRepository.create(player, conn);&#10;                            } catch (SQLException e) {&#10;                                throw new RuntimeException(e);&#10;                            }&#10;                        }));&#10;&#10;                // Gestion intelligente des photos simplifiée&#10;                List&lt;BattleReportPhoto&gt; existingPhotos = BattleReportPhotoRepository.findByBattleReportId(id);&#10;                List&lt;String&gt; existingFileNames = existingPhotos.stream()&#10;                        .map(BattleReportPhoto::getNameBattleReportPhoto)&#10;                        .toList();&#10;&#10;                List&lt;String&gt; newFileNames = Optional.ofNullable(battleReport.getPhotoFileNames())&#10;                        .orElse(new ArrayList&lt;&gt;());&#10;&#10;                // Ne supprimer que si la liste newFileNames n'est pas vide&#10;                if (!newFileNames.isEmpty()) {&#10;                    // Supprimer les photos qui ne sont plus dans la nouvelle liste&#10;                    existingPhotos.stream()&#10;                            .filter(photo -&gt; !newFileNames.contains(photo.getNameBattleReportPhoto()))&#10;                            .forEach(photo -&gt; {&#10;                                try {&#10;                                    queryRunner.update(conn, &quot;DELETE FROM battlereportphoto WHERE idBattleReportPhoto = ?&quot;,&#10;                                            photo.getIdBattleReportPhoto());&#10;                                } catch (SQLException e) {&#10;                                    throw new RuntimeException(e);&#10;                                }&#10;                            });&#10;&#10;                    // Ajouter les nouvelles photos qui n'existaient pas&#10;                    newFileNames.stream()&#10;                            .filter(fileName -&gt; !existingFileNames.contains(fileName))&#10;                            .forEach(fileName -&gt; {&#10;                                try {&#10;                                    BattleReportPhoto photo = new BattleReportPhoto();&#10;                                    photo.setBattleReport_idBattleReport(id);&#10;                                    photo.setNameBattleReportPhoto(fileName);&#10;                                    BattleReportPhotoRepository.create(photo, conn);&#10;                                } catch (SQLException e) {&#10;                                    throw new RuntimeException(e);&#10;                                }&#10;                            });&#10;                }&#10;&#10;                conn.commit();&#10;                return updatedRows;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                conn.setAutoCommit(false);&#10;&#10;                // Supprimer d'abord les dépendances dans une transaction&#10;                PlayerRepository.deleteByBattleReportId(id, conn);&#10;                BattleReportPhotoRepository.deleteByBattleReportId(id, conn);&#10;&#10;                // Puis supprimer le rapport principal&#10;                int result = queryRunner.update(conn, &quot;DELETE FROM battlereport WHERE idBattleReport = ?&quot;, id);&#10;&#10;                conn.commit();&#10;                return result;&#10;&#10;            } catch (SQLException e) {&#10;                try {&#10;                    conn.rollback();&#10;                } catch (SQLException rollbackEx) {&#10;                    rollbackEx.printStackTrace();&#10;                }&#10;                throw new RuntimeException(e);&#10;            } finally {&#10;                try {&#10;                    conn.setAutoCommit(true);&#10;                } catch (SQLException autoCommitEx) {&#10;                    autoCommitEx.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/PlayerRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/repository/PlayerRepository.java" />
              <option name="originalContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.Player;&#10;import org.apache.commons.dbutils.QueryRunner;&#10;import org.apache.commons.dbutils.ResultSetHandler;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.*;&#10;import java.util.List;&#10;&#10;public class PlayerRepository {&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;&#10;    public static List&lt;Player&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;Player&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(Player.class);&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM player&quot;, resultHandler);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static Player findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;Player&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(Player.class);&#10;            try {&#10;                List&lt;Player&gt; players = queryRunner.query(conn, &quot;SELECT * FROM player WHERE idPlayer = ?&quot;, resultHandler, id);&#10;                return players.isEmpty() ? null : players.get(0);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;Player&gt; findByBattleReportId(int idBattleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            ResultSetHandler&lt;List&lt;Player&gt;&gt; resultHandler = new BeanListHandler&lt;&gt;(Player.class);&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM player WHERE battleReport_idBattleReport = ?&quot;, resultHandler, idBattleReport);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // version create avec nouvelle connexion&#10;    public static int create(Player player) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return create(player, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // surcharge create avec connexion passée&#10;    public static int create(Player player, Connection conn) throws SQLException {&#10;        String sql = &quot;INSERT INTO player (playerName, playerScore, alliance_idAlliance, armyName_idArmyName, armyComposition_idArmyComposition, battleReport_idBattleReport) VALUES (?, ?, ?, ?, ?, ?)&quot;;&#10;        try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            stmt.setString(1, player.getPlayerName());&#10;            stmt.setString(2, player.getPlayerScore());&#10;            stmt.setInt(3, player.getAlliance_idAlliance());&#10;            stmt.setInt(4, player.getArmyName_idArmyName());&#10;            stmt.setInt(5, player.getArmyComposition_idArmyComposition());&#10;            stmt.setInt(6, player.getBattleReport_idBattleReport());&#10;&#10;            int affectedRows = stmt.executeUpdate();&#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;Creating player failed, no rows affected.&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    return generatedKeys.getInt(1);&#10;                } else {&#10;                    throw new SQLException(&quot;Creating player failed, no ID obtained.&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static int update(int id, Player player) throws SQLException {&#10;        String sql = &quot;UPDATE player SET playerName = ?, playerScore = ?, alliance_idAlliance = ?, armyName_idArmyName = ?, armyComposition_idArmyComposition = ?, battleReport_idBattleReport = ? WHERE idPlayer = ?&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, sql,&#10;                        player.getPlayerName(),&#10;                        player.getPlayerScore(),&#10;                        player.getAlliance_idAlliance(),&#10;                        player.getArmyName_idArmyName(),&#10;                        player.getArmyComposition_idArmyComposition(),&#10;                        player.getBattleReport_idBattleReport(),&#10;                        id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // version deleteByBattleReportId avec nouvelle connexion&#10;    public static int deleteByBattleReportId(int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return deleteByBattleReportId(battleReportId, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // surcharge deleteByBattleReportId avec connexion passée&#10;    public static int deleteByBattleReportId(int battleReportId, Connection conn) throws SQLException {&#10;        return queryRunner.update(conn,&#10;                &quot;DELETE FROM player WHERE battleReport_idBattleReport = ?&quot;,&#10;                battleReportId);&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, &quot;DELETE FROM player WHERE idPlayer = ?&quot;, id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.repository;&#10;&#10;import com.example.restservice.DatabaseSingleton;&#10;import com.example.restservice.model.Player;&#10;import org.apache.commons.dbutils.QueryRunner;&#10;import org.apache.commons.dbutils.ResultSetHandler;&#10;import org.apache.commons.dbutils.handlers.BeanListHandler;&#10;&#10;import java.sql.*;&#10;import java.util.List;&#10;&#10;public class PlayerRepository {&#10;&#10;    private static final QueryRunner queryRunner = new QueryRunner();&#10;    private static final DatabaseSingleton db = DatabaseSingleton.getInstance();&#10;    &#10;    // Handler réutilisable pour éviter la duplication&#10;    private static final ResultSetHandler&lt;List&lt;Player&gt;&gt; listHandler = &#10;            new BeanListHandler&lt;&gt;(Player.class);&#10;&#10;    public static List&lt;Player&gt; findAll() throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM player&quot;, listHandler);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static Player findById(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                List&lt;Player&gt; players = queryRunner.query(conn, &quot;SELECT * FROM player WHERE idPlayer = ?&quot;, listHandler, id);&#10;                return players.isEmpty() ? null : players.get(0);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    public static List&lt;Player&gt; findByBattleReportId(int idBattleReport) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.query(conn, &quot;SELECT * FROM player WHERE battleReport_idBattleReport = ?&quot;, listHandler, idBattleReport);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // version create avec nouvelle connexion&#10;    public static int create(Player player) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return create(player, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // surcharge create avec connexion passée&#10;    public static int create(Player player, Connection conn) throws SQLException {&#10;        String sql = &quot;INSERT INTO player (playerName, playerScore, alliance_idAlliance, armyName_idArmyName, armyComposition_idArmyComposition, battleReport_idBattleReport) VALUES (?, ?, ?, ?, ?, ?)&quot;;&#10;        try (PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {&#10;            stmt.setString(1, player.getPlayerName());&#10;            stmt.setString(2, player.getPlayerScore());&#10;            stmt.setInt(3, player.getAlliance_idAlliance());&#10;            stmt.setInt(4, player.getArmyName_idArmyName());&#10;            stmt.setInt(5, player.getArmyComposition_idArmyComposition());&#10;            stmt.setInt(6, player.getBattleReport_idBattleReport());&#10;&#10;            int affectedRows = stmt.executeUpdate();&#10;            if (affectedRows == 0) {&#10;                throw new SQLException(&quot;Creating player failed, no rows affected.&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    return generatedKeys.getInt(1);&#10;                } else {&#10;                    throw new SQLException(&quot;Creating player failed, no ID obtained.&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static int update(int id, Player player) throws SQLException {&#10;        String sql = &quot;UPDATE player SET playerName = ?, playerScore = ?, alliance_idAlliance = ?, armyName_idArmyName = ?, armyComposition_idArmyComposition = ?, battleReport_idBattleReport = ? WHERE idPlayer = ?&quot;;&#10;&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, sql,&#10;                        player.getPlayerName(),&#10;                        player.getPlayerScore(),&#10;                        player.getAlliance_idAlliance(),&#10;                        player.getArmyName_idArmyName(),&#10;                        player.getArmyComposition_idArmyComposition(),&#10;                        player.getBattleReport_idBattleReport(),&#10;                        id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // version deleteByBattleReportId avec nouvelle connexion&#10;    public static int deleteByBattleReportId(int battleReportId) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return deleteByBattleReportId(battleReportId, conn);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;&#10;    // surcharge deleteByBattleReportId avec connexion passée&#10;    public static int deleteByBattleReportId(int battleReportId, Connection conn) throws SQLException {&#10;        return queryRunner.update(conn,&#10;                &quot;DELETE FROM player WHERE battleReport_idBattleReport = ?&quot;,&#10;                battleReportId);&#10;    }&#10;&#10;    public static int delete(int id) throws SQLException {&#10;        return db.withConnection(conn -&gt; {&#10;            try {&#10;                return queryRunner.update(conn, &quot;DELETE FROM player WHERE idPlayer = ?&quot;, id);&#10;            } catch (SQLException e) {&#10;                throw new RuntimeException(e);&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/restservice/service/S3Service.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/restservice/service/S3Service.java" />
              <option name="updatedContent" value="package com.example.restservice.service;&#10;&#10;import io.github.cdimascio.dotenv.Dotenv;&#10;import org.springframework.stereotype.Service;&#10;import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;&#10;import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;&#10;import software.amazon.awssdk.core.ResponseBytes;&#10;import software.amazon.awssdk.core.sync.RequestBody;&#10;import software.amazon.awssdk.regions.Region;&#10;import software.amazon.awssdk.services.s3.S3Client;&#10;import software.amazon.awssdk.services.s3.model.*;&#10;import software.amazon.awssdk.services.s3.presigner.S3Presigner;&#10;import software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest;&#10;&#10;import java.io.InputStream;&#10;import java.net.URI;&#10;import java.time.Duration;&#10;&#10;@Service&#10;public class S3Service {&#10;&#10;    private final S3Client s3Client;&#10;    private final S3Presigner s3Presigner;&#10;    private final String bucketName = &quot;old-world-realms&quot;;&#10;    private static final String PHOTO_PREFIX = &quot;battle-report-photos/&quot;;&#10;&#10;    public S3Service() {&#10;        Dotenv dotenv = Dotenv.load();&#10;        AwsBasicCredentials credentials = AwsBasicCredentials.create(&#10;                dotenv.get(&quot;ACCESS_KEY&quot;),&#10;                dotenv.get(&quot;SECRET_KEY&quot;)&#10;        );&#10;&#10;        this.s3Client = S3Client.builder()&#10;                .region(Region.of(&quot;fr-par&quot;))&#10;                .credentialsProvider(StaticCredentialsProvider.create(credentials))&#10;                .endpointOverride(URI.create(&quot;https://s3.fr-par.scw.cloud&quot;))&#10;                .build();&#10;&#10;        this.s3Presigner = S3Presigner.builder()&#10;                .region(Region.of(&quot;fr-par&quot;))&#10;                .credentialsProvider(StaticCredentialsProvider.create(credentials))&#10;                .endpointOverride(URI.create(&quot;https://s3.fr-par.scw.cloud&quot;))&#10;                .build();&#10;    }&#10;&#10;    public void uploadFile(String fileName, InputStream inputStream, long size, String contentType) {&#10;        s3Client.putObject(&#10;                PutObjectRequest.builder()&#10;                        .bucket(bucketName)&#10;                        .key(PHOTO_PREFIX + fileName)&#10;                        .contentType(contentType)&#10;                        .build(),&#10;                RequestBody.fromInputStream(inputStream, size)&#10;        );&#10;    }&#10;&#10;    public ResponseBytes&lt;GetObjectResponse&gt; downloadFile(String fileName) {&#10;        return s3Client.getObjectAsBytes(&#10;                GetObjectRequest.builder()&#10;                        .bucket(bucketName)&#10;                        .key(PHOTO_PREFIX + fileName)&#10;                        .build()&#10;        );&#10;    }&#10;&#10;    public void deleteFile(String fileName) {&#10;        s3Client.deleteObject(&#10;                DeleteObjectRequest.builder()&#10;                        .bucket(bucketName)&#10;                        .key(PHOTO_PREFIX + fileName)&#10;                        .build()&#10;        );&#10;    }&#10;&#10;    public String getPresignedUrl(String fileName, Duration duration) {&#10;        PresignedGetObjectRequest presignedRequest = s3Presigner.presignGetObject(r -&gt; r&#10;                .signatureDuration(duration)&#10;                .getObjectRequest(GetObjectRequest.builder()&#10;                        .bucket(bucketName)&#10;                        .key(PHOTO_PREFIX + fileName)&#10;                        .build())&#10;        );&#10;        return presignedRequest.url().toString();&#10;    }&#10;&#10;    public String getPresignedUrl(String fileName) {&#10;        return getPresignedUrl(fileName, Duration.ofMinutes(15));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>