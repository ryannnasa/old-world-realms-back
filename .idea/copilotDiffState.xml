<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="# Étape de build&#10;FROM openjdk:17&#10;ARG JAR_FILE=build/libs/*.jar&#10;COPY ${JAR_FILE} app.jar&#10;COPY .env .env&#10;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]&#10;&#10;&#10;" />
              <option name="updatedContent" value="# Dockerfile optimisé pour production&#10;FROM eclipse-temurin:21-jre-jammy&#10;&#10;# Installer curl pour le health check&#10;RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*&#10;&#10;# Créer un utilisateur non-root pour la sécurité&#10;RUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser&#10;&#10;# Définir le répertoire de travail&#10;WORKDIR /app&#10;&#10;# Copier le JAR construit localement&#10;COPY build/libs/*.jar app.jar&#10;&#10;# Changer la propriété des fichiers&#10;RUN chown -R appuser:appuser /app&#10;&#10;# Passer à l'utilisateur non-root&#10;USER appuser&#10;&#10;# Exposer le port&#10;EXPOSE 8080&#10;&#10;# Configuration JVM optimisée&#10;ENV JAVA_OPTS=&quot;-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -XX:+UseG1GC&quot;&#10;&#10;# Health check&#10;HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \&#10;  CMD curl -f http://localhost:8080/actuator/health || exit 1&#10;&#10;# Point d'entrée&#10;ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -jar app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/example/restservice/controller/CsrfControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/example/restservice/controller/CsrfControllerTest.java" />
              <option name="originalContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.service.CsrfTokenService;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.security.test.context.support.WithMockUser;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(CsrfController.class)&#10;class CsrfControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @MockBean&#10;    private CsrfTokenService csrfTokenService;&#10;&#10;    @Test&#10;    void getCsrfToken_ShouldReturnValidToken() throws Exception {&#10;        mockMvc.perform(get(&quot;/csrf-token&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.success&quot;).value(true))&#10;                .andExpect(jsonPath(&quot;$.token&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.headerName&quot;).value(&quot;X-XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.parameterName&quot;).value(&quot;_csrf&quot;))&#10;                .andExpect(jsonPath(&quot;$.cookieName&quot;).value(&quot;XSRF-TOKEN&quot;));&#10;    }&#10;&#10;    @Test&#10;    void getCsrfInfo_ShouldReturnCsrfConfiguration() throws Exception {&#10;        mockMvc.perform(get(&quot;/csrf-info&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.csrfEnabled&quot;).value(true))&#10;                .andExpect(jsonPath(&quot;$.cookieName&quot;).value(&quot;XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.headerName&quot;).value(&quot;X-XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.parameterName&quot;).value(&quot;_csrf&quot;))&#10;                .andExpect(jsonPath(&quot;$.instructions&quot;).exists());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser&#10;    void testSecureEndpoint_WithValidCsrfToken_ShouldSucceed() throws Exception {&#10;        mockMvc.perform(post(&quot;/api/secure-endpoint&quot;)&#10;                        .with(csrf())&#10;                        .contentType(&quot;application/json&quot;)&#10;                        .content(&quot;{}&quot;))&#10;                .andExpect(status().isOk());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser&#10;    void testSecureEndpoint_WithoutCsrfToken_ShouldFail() throws Exception {&#10;        mockMvc.perform(post(&quot;/api/secure-endpoint&quot;)&#10;                        .contentType(&quot;application/json&quot;)&#10;                        .content(&quot;{}&quot;))&#10;                .andExpect(status().isForbidden());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.service.CsrfTokenService;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;&#10;import org.springframework.boot.test.mock.mockito.MockBean;&#10;import org.springframework.context.annotation.Import;&#10;import org.springframework.security.test.context.support.WithMockUser;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@WebMvcTest(CsrfController.class)&#10;@Import({com.example.restservice.config.SecurityConfig.class, com.example.restservice.config.CorsConfig.class})&#10;class CsrfControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @MockBean&#10;    private CsrfTokenService csrfTokenService;&#10;&#10;    @Test&#10;    void getCsrfToken_ShouldReturnValidToken() throws Exception {&#10;        mockMvc.perform(get(&quot;/csrf-token&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.success&quot;).value(true))&#10;                .andExpect(jsonPath(&quot;$.token&quot;).exists())&#10;                .andExpect(jsonPath(&quot;$.headerName&quot;).value(&quot;X-XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.parameterName&quot;).value(&quot;_csrf&quot;))&#10;                .andExpect(jsonPath(&quot;$.cookieName&quot;).value(&quot;XSRF-TOKEN&quot;));&#10;    }&#10;&#10;    @Test&#10;    void getCsrfInfo_ShouldReturnCsrfConfiguration() throws Exception {&#10;        mockMvc.perform(get(&quot;/csrf-info&quot;))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.csrfEnabled&quot;).value(true))&#10;                .andExpect(jsonPath(&quot;$.cookieName&quot;).value(&quot;XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.headerName&quot;).value(&quot;X-XSRF-TOKEN&quot;))&#10;                .andExpect(jsonPath(&quot;$.parameterName&quot;).value(&quot;_csrf&quot;))&#10;                .andExpect(jsonPath(&quot;$.instructions&quot;).exists());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser&#10;    void testSecureEndpoint_WithValidCsrfToken_ShouldSucceed() throws Exception {&#10;        mockMvc.perform(post(&quot;/api/secure-endpoint&quot;)&#10;                        .with(csrf())&#10;                        .contentType(&quot;application/json&quot;)&#10;                        .content(&quot;{}&quot;))&#10;                .andExpect(status().isOk());&#10;    }&#10;&#10;    @Test&#10;    @WithMockUser&#10;    void testSecureEndpoint_WithoutCsrfToken_ShouldFail() throws Exception {&#10;        mockMvc.perform(post(&quot;/api/secure-endpoint&quot;)&#10;                        .contentType(&quot;application/json&quot;)&#10;                        .content(&quot;{}&quot;))&#10;                .andExpect(status().isForbidden());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/example/restservice/controller/ImageUploadControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/example/restservice/controller/ImageUploadControllerTest.java" />
              <option name="originalContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import com.example.restservice.service.S3Service;&#10;import com.example.restservice.service.SecurityMonitoringService;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.MockedStatic;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.mock.web.MockHttpServletRequest;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import software.amazon.awssdk.core.ResponseBytes;&#10;import software.amazon.awssdk.services.s3.model.GetObjectResponse;&#10;import software.amazon.awssdk.services.s3.model.S3Exception;&#10;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.IOException;&#10;import java.sql.SQLException;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class ImageUploadControllerTest {&#10;&#10;    @Mock&#10;    private S3Service s3Service;&#10;&#10;    @Mock&#10;    private SecurityMonitoringService securityService;&#10;&#10;    @Mock&#10;    private MultipartFile multipartFile;&#10;&#10;    @InjectMocks&#10;    private ImageUploadController imageUploadController;&#10;&#10;    private MockHttpServletRequest mockRequest;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        mockRequest = new MockHttpServletRequest();&#10;        mockRequest.setRemoteAddr(&quot;127.0.0.1&quot;);&#10;&#10;        // Configuration des mocks pour éviter les NullPointerException&#10;        doNothing().when(securityService).recordSuspiciousActivity(anyString(), anyString());&#10;        doNothing().when(securityService).logSecurityEvent(anyString(), anyString(), anyString());&#10;        doNothing().when(securityService).validateInput(anyString(), anyString());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageSuccess() throws IOException, SQLException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenReturn(new ByteArrayInputStream(&quot;test&quot;.getBytes()));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        try (MockedStatic&lt;BattleReportPhotoRepository&gt; mockedRepo = mockStatic(BattleReportPhotoRepository.class)) {&#10;            mockedRepo.when(() -&gt; BattleReportPhotoRepository.create(any(BattleReportPhoto.class))).thenReturn(1);&#10;&#10;            ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;            assertEquals(HttpStatus.OK, result.getStatusCode());&#10;            assertNotNull(result.getBody());&#10;            assertTrue(result.getBody().contains(&quot;test.jpg&quot;));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageIOException() throws IOException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenThrow(new IOException(&quot;IO Error&quot;));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());&#10;        assertEquals(&quot;Upload failed&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageSQLException() throws SQLException, IOException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenReturn(new ByteArrayInputStream(&quot;test&quot;.getBytes()));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        try (MockedStatic&lt;BattleReportPhotoRepository&gt; mockedRepo = mockStatic(BattleReportPhotoRepository.class)) {&#10;            mockedRepo.when(() -&gt; BattleReportPhotoRepository.create(any(BattleReportPhoto.class))).thenThrow(new SQLException(&quot;SQL Error&quot;));&#10;&#10;            ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;            assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());&#10;            assertEquals(&quot;Upload failed&quot;, result.getBody());&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testDownloadImageSuccess() {&#10;        ResponseBytes&lt;GetObjectResponse&gt; mockResponse = mock(ResponseBytes.class);&#10;        GetObjectResponse getObjectResponse = mock(GetObjectResponse.class);&#10;&#10;        when(mockResponse.response()).thenReturn(getObjectResponse);&#10;        when(getObjectResponse.contentType()).thenReturn(&quot;image/jpeg&quot;);&#10;        when(mockResponse.asByteArray()).thenReturn(&quot;test&quot;.getBytes());&#10;        when(s3Service.downloadFile(&quot;test.jpg&quot;)).thenReturn(mockResponse);&#10;&#10;        ResponseEntity&lt;byte[]&gt; result = imageUploadController.downloadImage(&quot;test.jpg&quot;, mockRequest);&#10;&#10;        assertEquals(HttpStatus.OK, result.getStatusCode());&#10;        assertArrayEquals(&quot;test&quot;.getBytes(), result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testDownloadImageNotFound() {&#10;        when(s3Service.downloadFile(&quot;nonexistent.jpg&quot;)).thenThrow(S3Exception.builder().build());&#10;&#10;        ResponseEntity&lt;byte[]&gt; result = imageUploadController.downloadImage(&quot;nonexistent.jpg&quot;, mockRequest);&#10;&#10;        assertEquals(HttpStatus.NOT_FOUND, result.getStatusCode());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageEmptyFile() {&#10;        when(multipartFile.isEmpty()).thenReturn(true);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Fichier vide&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageTooLarge() {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getSize()).thenReturn(15L * 1024 * 1024); // 15MB&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Fichier trop volumineux&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageInvalidContentType() {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;text/plain&quot;);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Type de fichier non autorisé&quot;, result.getBody());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.restservice.controller;&#10;&#10;import com.example.restservice.model.BattleReportPhoto;&#10;import com.example.restservice.repository.BattleReportPhotoRepository;&#10;import com.example.restservice.service.S3Service;&#10;import com.example.restservice.service.SecurityMonitoringService;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.MockedStatic;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.mock.web.MockHttpServletRequest;&#10;import org.springframework.web.multipart.MultipartFile;&#10;import software.amazon.awssdk.core.ResponseBytes;&#10;import software.amazon.awssdk.services.s3.model.GetObjectResponse;&#10;import software.amazon.awssdk.services.s3.model.S3Exception;&#10;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.IOException;&#10;import java.sql.SQLException;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class ImageUploadControllerTest {&#10;&#10;    @Mock&#10;    private S3Service s3Service;&#10;&#10;    @Mock&#10;    private SecurityMonitoringService securityService;&#10;&#10;    @Mock&#10;    private BattleReportPhotoRepository battleReportPhotoRepository;&#10;&#10;    @Mock&#10;    private MultipartFile multipartFile;&#10;&#10;    @InjectMocks&#10;    private ImageUploadController imageUploadController;&#10;&#10;    private MockHttpServletRequest mockRequest;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        mockRequest = new MockHttpServletRequest();&#10;        mockRequest.setRemoteAddr(&quot;127.0.0.1&quot;);&#10;&#10;        // Configuration des mocks pour éviter les NullPointerException&#10;        doNothing().when(securityService).recordSuspiciousActivity(anyString(), anyString());&#10;        doNothing().when(securityService).logSecurityEvent(anyString(), anyString(), anyString());&#10;        doNothing().when(securityService).validateInput(anyString(), anyString());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageSuccess() throws IOException, SQLException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenReturn(new ByteArrayInputStream(&quot;test&quot;.getBytes()));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        try (MockedStatic&lt;BattleReportPhotoRepository&gt; mockedRepo = mockStatic(BattleReportPhotoRepository.class)) {&#10;            mockedRepo.when(() -&gt; BattleReportPhotoRepository.create(any(BattleReportPhoto.class))).thenReturn(1);&#10;&#10;            ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;            assertEquals(HttpStatus.OK, result.getStatusCode());&#10;            assertNotNull(result.getBody());&#10;            assertTrue(result.getBody().contains(&quot;test.jpg&quot;));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageIOException() throws IOException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenThrow(new IOException(&quot;IO Error&quot;));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());&#10;        assertEquals(&quot;Upload failed&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageSQLException() throws SQLException, IOException {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getOriginalFilename()).thenReturn(&quot;test.jpg&quot;);&#10;        when(multipartFile.getInputStream()).thenReturn(new ByteArrayInputStream(&quot;test&quot;.getBytes()));&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;image/jpeg&quot;);&#10;&#10;        try (MockedStatic&lt;BattleReportPhotoRepository&gt; mockedRepo = mockStatic(BattleReportPhotoRepository.class)) {&#10;            mockedRepo.when(() -&gt; BattleReportPhotoRepository.create(any(BattleReportPhoto.class))).thenThrow(new SQLException(&quot;SQL Error&quot;));&#10;&#10;            ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;            assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());&#10;            assertEquals(&quot;Upload failed&quot;, result.getBody());&#10;        }&#10;    }&#10;&#10;    @Test&#10;    void testDownloadImageSuccess() {&#10;        ResponseBytes&lt;GetObjectResponse&gt; mockResponse = mock(ResponseBytes.class);&#10;        GetObjectResponse getObjectResponse = mock(GetObjectResponse.class);&#10;&#10;        when(mockResponse.response()).thenReturn(getObjectResponse);&#10;        when(getObjectResponse.contentType()).thenReturn(&quot;image/jpeg&quot;);&#10;        when(mockResponse.asByteArray()).thenReturn(&quot;test&quot;.getBytes());&#10;        when(s3Service.downloadFile(&quot;test.jpg&quot;)).thenReturn(mockResponse);&#10;&#10;        ResponseEntity&lt;byte[]&gt; result = imageUploadController.downloadImage(&quot;test.jpg&quot;, mockRequest);&#10;&#10;        assertEquals(HttpStatus.OK, result.getStatusCode());&#10;        assertArrayEquals(&quot;test&quot;.getBytes(), result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testDownloadImageNotFound() {&#10;        when(s3Service.downloadFile(&quot;nonexistent.jpg&quot;)).thenThrow(S3Exception.builder().build());&#10;&#10;        ResponseEntity&lt;byte[]&gt; result = imageUploadController.downloadImage(&quot;nonexistent.jpg&quot;, mockRequest);&#10;&#10;        assertEquals(HttpStatus.NOT_FOUND, result.getStatusCode());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageEmptyFile() {&#10;        when(multipartFile.isEmpty()).thenReturn(true);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Fichier vide&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageTooLarge() {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getSize()).thenReturn(15L * 1024 * 1024); // 15MB&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Fichier trop volumineux&quot;, result.getBody());&#10;    }&#10;&#10;    @Test&#10;    void testUploadImageInvalidContentType() {&#10;        when(multipartFile.isEmpty()).thenReturn(false);&#10;        when(multipartFile.getSize()).thenReturn(4L);&#10;        when(multipartFile.getContentType()).thenReturn(&quot;text/plain&quot;);&#10;&#10;        ResponseEntity&lt;String&gt; result = imageUploadController.uploadImage(multipartFile, 1, mockRequest);&#10;&#10;        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());&#10;        assertEquals(&quot;Type de fichier non autorisé&quot;, result.getBody());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>